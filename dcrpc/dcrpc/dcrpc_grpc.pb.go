// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: dcrpc.proto

package dcrpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Dcrpc_Ping_FullMethodName          = "/dcrpc.Dcrpc/Ping"
	Dcrpc_SetLocalhost_FullMethodName  = "/dcrpc.Dcrpc/SetLocalhost"
	Dcrpc_GetLocalhost_FullMethodName  = "/dcrpc.Dcrpc/GetLocalhost"
	Dcrpc_CalcDistance_FullMethodName  = "/dcrpc.Dcrpc/CalcDistance"
	Dcrpc_NearbyDrivers_FullMethodName = "/dcrpc.Dcrpc/NearbyDrivers"
	Dcrpc_Amount_FullMethodName        = "/dcrpc.Dcrpc/Amount"
	Dcrpc_MongoDB_FullMethodName       = "/dcrpc.Dcrpc/MongoDB"
	Dcrpc_Total_FullMethodName         = "/dcrpc.Dcrpc/Total"
	Dcrpc_Receive_FullMethodName       = "/dcrpc.Dcrpc/Receive"
	Dcrpc_EndOrder_FullMethodName      = "/dcrpc.Dcrpc/EndOrder"
	Dcrpc_MonDBCreate_FullMethodName   = "/dcrpc.Dcrpc/MonDBCreate"
)

// DcrpcClient is the client API for Dcrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DcrpcClient interface {
	Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	// 今日份打车所得税
	SetLocalhost(ctx context.Context, in *SetLocalhostRequest, opts ...grpc.CallOption) (*SetLocalhostResponse, error)
	GetLocalhost(ctx context.Context, in *GetLocalhostRequest, opts ...grpc.CallOption) (*GetLocalhostResponse, error)
	CalcDistance(ctx context.Context, in *CalcDistanceRequest, opts ...grpc.CallOption) (*CalcDistanceResponse, error)
	NearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error)
	Amount(ctx context.Context, in *AmountRequest, opts ...grpc.CallOption) (*AmountResponse, error)
	MongoDB(ctx context.Context, in *MongoDBRequest, opts ...grpc.CallOption) (*MongoDBResponse, error)
	Total(ctx context.Context, in *TotalRequest, opts ...grpc.CallOption) (*TotalResponse, error)
	Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (*ReceiveResponse, error)
	EndOrder(ctx context.Context, in *EndOrderRequest, opts ...grpc.CallOption) (*EndOrderResponse, error)
	MonDBCreate(ctx context.Context, in *MonDBCreateRequest, opts ...grpc.CallOption) (*MonDBCreateResponse, error)
}

type dcrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewDcrpcClient(cc grpc.ClientConnInterface) DcrpcClient {
	return &dcrpcClient{cc}
}

func (c *dcrpcClient) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Dcrpc_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) SetLocalhost(ctx context.Context, in *SetLocalhostRequest, opts ...grpc.CallOption) (*SetLocalhostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLocalhostResponse)
	err := c.cc.Invoke(ctx, Dcrpc_SetLocalhost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) GetLocalhost(ctx context.Context, in *GetLocalhostRequest, opts ...grpc.CallOption) (*GetLocalhostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLocalhostResponse)
	err := c.cc.Invoke(ctx, Dcrpc_GetLocalhost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) CalcDistance(ctx context.Context, in *CalcDistanceRequest, opts ...grpc.CallOption) (*CalcDistanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalcDistanceResponse)
	err := c.cc.Invoke(ctx, Dcrpc_CalcDistance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) NearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NearbyDriversResponse)
	err := c.cc.Invoke(ctx, Dcrpc_NearbyDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) Amount(ctx context.Context, in *AmountRequest, opts ...grpc.CallOption) (*AmountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AmountResponse)
	err := c.cc.Invoke(ctx, Dcrpc_Amount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) MongoDB(ctx context.Context, in *MongoDBRequest, opts ...grpc.CallOption) (*MongoDBResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MongoDBResponse)
	err := c.cc.Invoke(ctx, Dcrpc_MongoDB_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) Total(ctx context.Context, in *TotalRequest, opts ...grpc.CallOption) (*TotalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotalResponse)
	err := c.cc.Invoke(ctx, Dcrpc_Total_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (*ReceiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReceiveResponse)
	err := c.cc.Invoke(ctx, Dcrpc_Receive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) EndOrder(ctx context.Context, in *EndOrderRequest, opts ...grpc.CallOption) (*EndOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndOrderResponse)
	err := c.cc.Invoke(ctx, Dcrpc_EndOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dcrpcClient) MonDBCreate(ctx context.Context, in *MonDBCreateRequest, opts ...grpc.CallOption) (*MonDBCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MonDBCreateResponse)
	err := c.cc.Invoke(ctx, Dcrpc_MonDBCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DcrpcServer is the server API for Dcrpc service.
// All implementations must embed UnimplementedDcrpcServer
// for forward compatibility.
type DcrpcServer interface {
	Ping(context.Context, *Request) (*Response, error)
	// 今日份打车所得税
	SetLocalhost(context.Context, *SetLocalhostRequest) (*SetLocalhostResponse, error)
	GetLocalhost(context.Context, *GetLocalhostRequest) (*GetLocalhostResponse, error)
	CalcDistance(context.Context, *CalcDistanceRequest) (*CalcDistanceResponse, error)
	NearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error)
	Amount(context.Context, *AmountRequest) (*AmountResponse, error)
	MongoDB(context.Context, *MongoDBRequest) (*MongoDBResponse, error)
	Total(context.Context, *TotalRequest) (*TotalResponse, error)
	Receive(context.Context, *ReceiveRequest) (*ReceiveResponse, error)
	EndOrder(context.Context, *EndOrderRequest) (*EndOrderResponse, error)
	MonDBCreate(context.Context, *MonDBCreateRequest) (*MonDBCreateResponse, error)
	mustEmbedUnimplementedDcrpcServer()
}

// UnimplementedDcrpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDcrpcServer struct{}

func (UnimplementedDcrpcServer) Ping(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDcrpcServer) SetLocalhost(context.Context, *SetLocalhostRequest) (*SetLocalhostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLocalhost not implemented")
}
func (UnimplementedDcrpcServer) GetLocalhost(context.Context, *GetLocalhostRequest) (*GetLocalhostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocalhost not implemented")
}
func (UnimplementedDcrpcServer) CalcDistance(context.Context, *CalcDistanceRequest) (*CalcDistanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalcDistance not implemented")
}
func (UnimplementedDcrpcServer) NearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NearbyDrivers not implemented")
}
func (UnimplementedDcrpcServer) Amount(context.Context, *AmountRequest) (*AmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Amount not implemented")
}
func (UnimplementedDcrpcServer) MongoDB(context.Context, *MongoDBRequest) (*MongoDBResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MongoDB not implemented")
}
func (UnimplementedDcrpcServer) Total(context.Context, *TotalRequest) (*TotalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Total not implemented")
}
func (UnimplementedDcrpcServer) Receive(context.Context, *ReceiveRequest) (*ReceiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Receive not implemented")
}
func (UnimplementedDcrpcServer) EndOrder(context.Context, *EndOrderRequest) (*EndOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndOrder not implemented")
}
func (UnimplementedDcrpcServer) MonDBCreate(context.Context, *MonDBCreateRequest) (*MonDBCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonDBCreate not implemented")
}
func (UnimplementedDcrpcServer) mustEmbedUnimplementedDcrpcServer() {}
func (UnimplementedDcrpcServer) testEmbeddedByValue()               {}

// UnsafeDcrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DcrpcServer will
// result in compilation errors.
type UnsafeDcrpcServer interface {
	mustEmbedUnimplementedDcrpcServer()
}

func RegisterDcrpcServer(s grpc.ServiceRegistrar, srv DcrpcServer) {
	// If the following call pancis, it indicates UnimplementedDcrpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Dcrpc_ServiceDesc, srv)
}

func _Dcrpc_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).Ping(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_SetLocalhost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLocalhostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).SetLocalhost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_SetLocalhost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).SetLocalhost(ctx, req.(*SetLocalhostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_GetLocalhost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocalhostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).GetLocalhost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_GetLocalhost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).GetLocalhost(ctx, req.(*GetLocalhostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_CalcDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcDistanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).CalcDistance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_CalcDistance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).CalcDistance(ctx, req.(*CalcDistanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_NearbyDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NearbyDriversRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).NearbyDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_NearbyDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).NearbyDrivers(ctx, req.(*NearbyDriversRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_Amount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).Amount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_Amount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).Amount(ctx, req.(*AmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_MongoDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MongoDBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).MongoDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_MongoDB_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).MongoDB(ctx, req.(*MongoDBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_Total_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TotalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).Total(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_Total_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).Total(ctx, req.(*TotalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_Receive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).Receive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_Receive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).Receive(ctx, req.(*ReceiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_EndOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).EndOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_EndOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).EndOrder(ctx, req.(*EndOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dcrpc_MonDBCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MonDBCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DcrpcServer).MonDBCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dcrpc_MonDBCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DcrpcServer).MonDBCreate(ctx, req.(*MonDBCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Dcrpc_ServiceDesc is the grpc.ServiceDesc for Dcrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Dcrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dcrpc.Dcrpc",
	HandlerType: (*DcrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Dcrpc_Ping_Handler,
		},
		{
			MethodName: "SetLocalhost",
			Handler:    _Dcrpc_SetLocalhost_Handler,
		},
		{
			MethodName: "GetLocalhost",
			Handler:    _Dcrpc_GetLocalhost_Handler,
		},
		{
			MethodName: "CalcDistance",
			Handler:    _Dcrpc_CalcDistance_Handler,
		},
		{
			MethodName: "NearbyDrivers",
			Handler:    _Dcrpc_NearbyDrivers_Handler,
		},
		{
			MethodName: "Amount",
			Handler:    _Dcrpc_Amount_Handler,
		},
		{
			MethodName: "MongoDB",
			Handler:    _Dcrpc_MongoDB_Handler,
		},
		{
			MethodName: "Total",
			Handler:    _Dcrpc_Total_Handler,
		},
		{
			MethodName: "Receive",
			Handler:    _Dcrpc_Receive_Handler,
		},
		{
			MethodName: "EndOrder",
			Handler:    _Dcrpc_EndOrder_Handler,
		},
		{
			MethodName: "MonDBCreate",
			Handler:    _Dcrpc_MonDBCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dcrpc.proto",
}
